/*
* architecture
  * tree
    * end -> router/end -> router
  * priority
    * prefer high priority router on register. by fast response than low priority's
    * pure end's priority should consider as 0;
    * should set priorityBase greater than self's while register
  * boardcast
    * boardcast use rx pipe 0, address is const
  * peer2peer
    * peer2peer use rx pipe 1, address is generated by router in register.
      * router/end's address can be prefer by self, but will be change if the address conflic in the router.
        * prefer address id calculate by uid of the chip, which is unique.
  * id
    * end's id is generate by router in register and send back to end
    * end->router communicate id should be the id router generated.
    * router->end communicate id should be 0.
  * register
    * end boardcast with {id=0}
    * all router mathered will generat register for the end, but prefer address response at once, others response in 250us per priority point.
    * end pick the fastest response router as its router
    * the router register list will be recovered if timeout or register size == 255. timeout = 2hour by default.
  * communicate
    * end peer2peer with identify
    * the router response using nest downloadPackage, ignore identify.
    * the router add request to nest uploadPackage
    * end will clear identify unless error occurs.

* register: start by end once reset
  * end
    * serialized package: {priorityBase:$0, priorityRange:$1, [o]preferAddress: $2, [o]preferRouterAddress: $3, [o]receivingWhileIdle: $4}
    * tx: {address:broadcast,bytes: {id:0, data:serialized}}, noack:true}
    * rx: {address:broadcast,timeout: 250us*(priorityRange + 1)} ==> [1]
  * router
    * rx: {address:broadcast, timeout: 0};
      * if: id == 0 && (package.data.preferRouterAddress == self.address || self.priority >= package.data.priorityBase && self.priority < package.data.priorityBase + package.data.priorityRange)
        * memory: new register: {id: $0, address: package.data.preferAddress?$1}. NOTE: package.data.preferAddress should be unique as well;
        * wait: package.data.preferRouterAddress == self.address?0:(package.data.priorityBase + package.data.priorityRange - $self.priority)*250us;
        * serialize package: {endId:register.id, endAddress:register.address, routerAddress:self.address}
        * tx: {address:broadcast,bytes: {id:0, data: serialized}, noack:true}
  * end
    * [1] ==>
      * memory: self.id = package.endId; self.routerAddress = package.routerAddress;
      * hw: p2pAddress = self.endAddress;

* communicate: start by end in repeat schedule
  * end
    * generate return bytes by uploadPackage, ignore identify by identify ignore flag.
    * tx: {address:self.routerAddress, bytes: bytes, noack:true}
    * rx: {address:self.address,timeout: 250us*(2+pages)} ==> [2]
  * router
    * rx: {address:self.address, timeout: 0};
      * memory: find register by package.id;
      * generate return bytes by downloadPackage, ignore identify.
      * tx: {address:register.address, bytes:bytes, noack:true}
      * memory: add to uploadPackage; //do upload might be occurse in next server push.
        * override basic - deviceId, version, router, sessionId
        * override data
        * insert command by lines
        * override requenst by keys
        * override line
  * end
    * [2] ==>
      * if (id == 0)
        * onReceive
        * clear identify ignore flag if error, set flag otherwise
*/
#ifndef NRF24_CLIENT_H__
#define NRF24_CLIENT_H__

#include "frameworks/nrf24.h"

typedef struct nrf24_client_t nrf24_client_t;
typedef struct nrf24_cache_t nrf24_cache_t;
typedef struct nrf24_page_t nrf24_page_t;
typedef struct nrf24_register_t nrf24_register_t;

typedef void (*nrf24_notifyFunction_t) (nrf24_client_t* client, nrf24_register_t* r);
typedef void (*nrf24_communicateFunction_t) (nrf24_client_t* client, uint8_t* bytes, int16_t size);
#define NRF24_PAGE_MAX_SIZE 32
#define NRF24_PAGE_DATA_SIZE 28
#define NRF24_PAGE_INFO_SIZE (NRF24_PAGE_MAX_SIZE - NRF24_PAGE_DATA_SIZE)

enum {
  NRF24_PIPE_broadcast,
  NRF24_PIPE_peer2peer,
  NRF24_PIPE_SIZE,
};

enum {
  NRF24_PAGE_id,
  NRF24_PAGE_line,
  NRF24_PAGE_index,
  NRF24_PAGE_total,
  NRF24_PAGE_data,
};

struct nrf24_page_t {
  uint8_t id;
  uint8_t index;
  uint8_t total;
  uint8_t line;
  uint8_t data;
};

struct nrf24_cache_t {
  int16_t gotPages;
  int16_t totalPages;
  int16_t line;
  int8_t lastPageSize;
  uint32_t tick;
};

struct nrf24_client_t {
  nrf24_t* nrf24;
  uint32_t address;
  uint8_t line;
  struct {
    nrf24_communicateFunction_t onCommunicated;
    uint8_t id;
    uint8_t line;
    nrf24_cache_t* cache;
    uint32_t routerAddress;
  } asEnd;
  struct {
    nrf24_notifyFunction_t initRegister;
    nrf24_notifyFunction_t recoverRegister;
    uint8_t priority;
    uint8_t registerIdGenerator;
    list_t* registereds;
  } asRouter;
};

typedef struct nrf24_registerConfig_t {
  uint8_t priorityBase;
  uint8_t priorityRange;
  uint8_t usePreferRouterAddress;
  uint32_t preferRouterAddress;
  uint8_t receivingWhileIdle;
} nrf24_registerConfig_t;


struct nrf24_register_t {
  uint32_t id;
  uint32_t tick;
  uint32_t address;
  nrf24_cache_t* cache;
  uint8_t line;
  uint8_t receivingWhileIdle;
  package_element_t* upload;
  package_element_t* download;
};

nrf24_sequence_t* nrf24_generateTransmitSequence(uint32_t address, uint8_t id, uint8_t* buffer, int16_t size);
nrf24_sequence_t* nrf24_generateReceiveSequence(nrf24_dataFunction_t function, uint32_t timeout, uint8_t pipe);
nrf24_sequence_t* nrf24_generateGroupSequence(int8_t doTimes, nrf24_sequence_t** sequences, int16_t size);

uint8_t nrf24Client_routerDownloadUpdated(nrf24_client_t* client, nrf24_register_t*reg);
void nrf24Client_init(nrf24_client_t* client, uint8_t receivingWhileIdle);
void nrf24Client_enable(nrf24_client_t* client, uint8_t enable);

#endif
